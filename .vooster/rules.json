{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. 개요\n연구자가 특정 연구 분야를 선택하면 최신 논문을 자동 수집‧벡터 검색하여 RAG 기반 요약을 생성한다. 요약에는 연구 문제(problem), 해결 방법(solution), 기여(contribution), 핵심 figure 및 설명이 포함된다. 이를 통해 폭증하는 연구 정보를 신속히 파악하고 핵심 연구에 집중할 수 있게 한다.\n\n## 2. 문제 정의\n- 논문 발행 속도 증가로 관련 연구를 모두 읽기 어려움  \n- 키워드 기반 검색은 정확도·재현율 한계  \n- 요약 서비스 다수 존재하지만 문제·해결·기여를 구조화해 제공하지 않음  \n- 연구자는 핵심 figure를 포함한 시각적 요약을 선호하나 지원 서비스 부족\n\n## 3. 목표 및 목적\n- 1차 목표: 연구 분야별 최신 논문을 구조화된 요약으로 제공  \n- 2차 목표: 알림·추천으로 반복 방문 유도, 협업 기능 확장  \n- 성공 지표  \n  - MAU 5,000 (런칭 6개월)  \n  - 논문 요약 클릭당 평균 3분 체류  \n  - 요약 정확도 사용자 만족도 85% 이상  \n  - 재방문률 30% 이상\n\n## 4. 대상 사용자\n### 주요 사용자\n- 대학원생‧포닥: 실험 설계 전 최신 연구 파악 필요  \n- 산업 연구원: 시장·기술 트렌드 조기 감지  \n- 교수·PI: 논문 리뷰, 연구 방향성 설정  \n공통 니즈: 빠르고 정확한 구조화 요약, figure 포함 시각적 이해\n\n### 이해 관계자\n- 대학·기업 도서관  \n- 학회·저널 퍼블리셔  \n- 투자사 기술 분석팀\n\n## 5. 사용자 스토리\n- 연구자로서, 특정 분야를 입력하면 최신 논문 핵심을 1분 내 파악하고 싶다.  \n- 연구자로서, 문제/해결/기여를 한눈에 비교해 유망 논문을 선별하고 싶다.  \n- 연구자로서, 핵심 figure와 설명을 확인해 방법론을 빠르게 이해하고 싶다.  \n- 연구자로서, 새 논문이 추가되면 이메일/Slack으로 알림받고 싶다.  \n- 연구자로서, 요약을 팀원과 공유·코멘트하고 싶다.\n\n## 6. 기능 요구 사항\n### 핵심 기능\n1. 연구 분야 입력 & 벡터 검색  \n   - 사용자가 텍스트/키워드로 분야 명세  \n   - embedding index 구축(Supabase pgvector)  \n   - 일치 논문 상위 N편 반환  \n   - 수용 기준: 95% 이상 관련도 검출\n2. RAG 기반 요약 생성  \n   - LangChain + LLM 사용  \n   - problem, solution, contribution, figure 캡션 추출  \n   - 출력 길이: 500자 이하, 표준 템플릿  \n   - 수용 기준: BLEU > 0.4, 사용자 평가 4/5\n3. 핵심 figure 추출 및 설명  \n   - arXiv PDF 파싱 → 이미지 추출 → OCR/캡션  \n   - 요약 카드에 썸네일 표시, 클릭 시 확대  \n4. 웹 UI  \n   - React 기반 대시보드  \n   - 검색창, 요약 카드 그리드, 필터(연도, 저널)  \n   - 반응형(모바일/데스크톱)\n\n### 부가 기능 (Nice-to-have)\n5. 개인 알림/추천  \n   - 신규 논문 크롤링 배치, 관심 분야 저장  \n6. 협업 메모 & 공유  \n   - 요약에 댓글, 태그, 링크 생성  \n7. 다국어 번역  \n   - 한국어/영어 자동 전환  \n8. API 제공  \n   - 사내 시스템 연동용 REST/GraphQL\n\n## 7. 비기능 요구 사항\n- 성능: 검색+요약 End-to-End 10초 이하  \n- 정확성: 요약 사실 오류율 <5%  \n- 보안: OAuth2 로그인, HTTPS, GDPR 준수  \n- 확장성: 월 100만 요약 처리, k8s 오토스케일  \n- 호환성: Chrome, Edge, Safari 최신 2버전, 모바일 Safari/Chrome\n\n## 8. 기술 고려 사항\n- 아키텍처: React(Next.js) SPA + FastAPI 서버  \n- 파이프라인: Python, LangChain, OpenAI GPT-4o 또는 Anthropic Claude  \n- 데이터: arXiv API, CrossRef, Semantic Scholar API  \n- DB: Supabase(PostgreSQL), pgvector  \n- 캐시: Redis, CDN 이미지 딜리버리  \n- 서드파티: HuggingFace transformers, PDFMiner, Slack API\n\n## 9. 성공 지표\n- 사용자 지표: MAU, 세션 길이, 재방문률  \n- 비즈니스 지표: 유료 구독 전환 5% (1년 내), 팀 요금제 ARPU $40  \n- 기술 지표: 평균 응답 5초 이하, 가용성 99.5%\n\n## 10. 일정 및 마일스톤\n- Phase 1 (0~3개월)  \n  - 핵심 기능 1~4, 기본 UI, AWS 배포(MVP)  \n- Phase 2 (3~6개월)  \n  - 알림·추천, 협업 메모, 다국어 번역, 성능 최적화  \n- Phase 3 (6~12개월)  \n  - API 공개, 기관용 어드민, 지식 그래프 시각화\n\n## 11. 위험 및 대응\n- LLM 환각 → RAG·출처 링크·인용 표기 강화  \n- 논문 저작권 이슈 → 공개 접근(arXiv) 우선, 퍼블리셔 라이선스 협상  \n- 높은 클라우드 비용 → 요약 캐싱, GPU 스팟 인스턴스  \n- 낮은 사용자 신뢰 → 전문가 검수 프로그램, 피드백 루프\n\n## 12. 향후 고려 사항\n- 개인화 지식 그래프로 연구 아이디어 추천  \n- 음성 요약(팟캐스트 형식)  \n- 학회 일정·Call for Papers 통합  \n- 온프레미스 배포(대기업 연구소)  \n\n(문서 길이: 약 3,000자)",
      "writedAt": "2025-07-15T04:56:12.214Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  연구자가 선택한 분야의 최신 논문을 자동 수집·벡터 검색하여 RAG 기반으로 구조화된 요약(problem, solution, contribution, figure 포함)을 제공. 웹 UI를 통한 연구 효율 극대화.\n- **핵심 기술 스택**  \n  Frontend: Next.js(React)  \n  Backend/API: FastAPI(Python) + LangChain  \n  LLM: OpenAI GPT-4.1 mini  \n  DB: Supabase(PostgreSQL) + pgvector  \n  캐시: Redis  \n  PDF 파싱: PyMuPDF (fitz)  \n  배포: AWS(ECS/EKS) + CDN  \n- **주요 기술 목표**  \n  • 검색+요약 응답 시간 ≤15초, 스트리밍 UI로 체감 속도 개선  \n  • 요약 정확도 BLEU>0.4, 사용자 평가 ≥4/5  \n  • 월 100만 건 요약 처리 가능 확장성  \n  • 가용성 99.5% 이상  \n- **핵심 가정**  \n  • 공개 접근(arXiv) 논문 위주 수집  \n  • 초기 사용자 5,000명 규모 예상  \n  • 클라우드 기반 오토스케일링 활용  \n  • GDPR·OAuth2 인증 필수\n\n## 2. Tech Stack\n\n| Category           | Technology / Library         | Reasoning (선택 이유)                                  |\n| ------------------ | ---------------------------- | ----------------------------------------------------- |\n| Frontend Framework | Next.js (React)              | SEO 지원, SSR/SSG로 빠른 초기 로드 및 반응형 UI 구현   |\n| Backend Framework  | FastAPI                      | 비동기 처리, 타입 지원, 빠른 개발 속도                |\n| 언어               | Python                       | LangChain·ORM 등 풍부한 생태계               |\n| RAG Orchestration  | LangChain                    | 모듈화된 파이프라인, 다양한 LLM 연동 지원              |\n| LLM Provider       | OpenAI GPT-4.1 mini          | 경량화된 최신 LLM, 빠른 응답 속도, 비용 효율           |\n| Database           | Supabase (PostgreSQL + pgvector) | 벡터 검색 내장, 관리형 서비스로 운영 편의성           |\n| ORM                | SQLAlchemy (또는 Supabase SDK)| Python 친화적, 확장성 있는 쿼리/매핑                 |\n| 캐시 & 큐          | Redis                        | 세션·알림·배치 큐로 사용, 인메모리 성능                |\n| PDF 파싱 & OCR     | PyMuPDF (fitz)     | 고정밀도 PDF→텍스트·이미지 추출                       |\n| 이미지 CDN         | AWS CloudFront               | 전세계 빠른 이미지 딜리버리                   |         \n| 배포 & 오케스트레이션 | AWS ECS/EKS, Docker         | 컨테이너 기반 자동 확장, 관리형 Kubernetes 지원       |\n| CI/CD              | GitHub Actions               | 코드 푸시 자동 테스트·배포 파이프라인                  |\n\n## 3. System Architecture Design\n\n### 파이프라인 기반 아키텍처 개요\n전체 시스템은 데이터 준비를 위한 **오프라인 배치 파이프라인**과, 사용자 요청을 실시간으로 처리하는 **온라인 서빙 파이프라인**으로 분리되어 설계됩니다.\n\n#### 1. 오프라인 배치 파이프라인 (데이터 준비)\n- **스케줄러/오케스트레이션**: (예: Airflow, Celery Beat, Kubernetes CronJob)\n- **논문 메타데이터 수집**: arXiv, Semantic Scholar, CrossRef API 활용, 중복 체크 및 저장\n- **PDF 파싱 및 콘텐츠 추출**: PyMuPDF/nougat 활용, 텍스트·이미지 추출 후 정제, S3 업로드 및 DB 기록\n- **텍스트 분할 및 임베딩**: RecursiveCharacterTextSplitter, KoSimCSE-roberta, text-embedding-3-small 등 임베딩 모델 적용, pgvector 저장 및 인덱싱\n- **핵심 요약 사전 생성**: LLM 기반 사전 요약 생성 및 별도 테이블 저장\n\n#### 2. 온라인 서빙 파이프라인 (사용자 요청 실시간 처리)\n- **React 프론트엔드**: 사용자 쿼리 입력\n- **FastAPI 백엔드**: 쿼리 임베딩, 동일 임베딩 모델 사용\n- **벡터 검색(pgvector)**: 쿼리 임베딩과 유사한 Chunk 검색\n- **프롬프트 생성 및 LLM 호출**: 구조화된 프롬프트, RAG 기반 요약(JSON)\n- **핵심 Figure 선정 및 결합**: 요약 결과와 Figure/캡션 결합\n- **Redis 캐싱**: 논문 단위 캐싱 및 응답 속도/비용 최적화\n- **프론트엔드 결과 시각화**\n\n### 전체 파이프라인 컴포넌트 및 상호작용 다이어그램\n```\nmermaid\ngraph TD\n    subgraph Offline Pipeline\n      A1[Scheduler/CronJob] --> A2[Paper Metadata Collector]\n      A2 --> A3[PDF Parser (PyMuPDF/nougat)]\n      A3 --> A4[Text/Image Extractor]\n      A4 --> A5[Chunking & Embedding]\n      A5 --> A6[Pre-compute Summarizer (LLM)]\n      A6 -->|Store| D1[Supabase PostgreSQL + pgvector]\n      A4 -->|Upload| E1[S3]\n    end\n    \n    subgraph Online Pipeline\n      B1[Next.js Frontend] -->|REST| B2[FastAPI Backend]\n      B2 -->|Query Embedding| B3[Embedding Model]\n      B2 -->|Vector Search| D1\n      B2 -->|Cache| C1[Redis]\n      B2 -->|Prompt| B4[LLM]\n      B2 -->|Figure & Caption| E1\n      B2 -->|Summary+Figures| B1\n    end\n```\n\n- 오프라인 파이프라인은 논문 수집부터 임베딩, 사전 요약까지 자동화, DB/S3에 결과 저장\n- 온라인 파이프라인은 쿼리 임베딩, 벡터 검색, LLM 요약, Figure 결합, 캐싱 최적화로 실시간 응답 제공\n\n- React 기반 UI가 FastAPI로 검색·요약 요청  \n- FastAPI는 pgvector에서 유사 논문 검색 후 LangChain 파이프라인 실행  \n- PDFParser 모듈이 figure 추출→S3에 저장→CloudFront로 제공  \n- Redis로 결과 캐싱 및 알림 큐 관리  \n\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**  \n- **도메인 분리**: user, paper, summarize  \n- **레이어 아키텍처**: presentation → service → repository → infrastructure  \n- **기능 모듈화**: 각 도메인별 모듈 단위 관리  \n- **공통 컴포넌트**: utils, types, config, exceptions\n\n**Universal File & Folder Structure**\n```\n/\n├── backend/\n│   ├── app/\n│   │   ├── domains/\n│   │   │   ├── user/\n│   │   │   ├── paper/\n│   │   │   ├── summarize/\n\n│   │   ├── services/\n│   │   ├── repositories/\n│   │   ├── infrastructure/\n│   │   ├── api/        # FastAPI 라우터\n│   │   ├── core/       # 설정, 로깅, 예외처리\n│   │   └── main.py\n│   ├── Dockerfile\n│   └── requirements.txt\n├── frontend/\n│   ├── components/\n│   ├── pages/\n│   ├── styles/\n│   └── next.config.js\n├── crawler/           # 논문 크롤러 배치 스크립트\n├── infra/             # IaC (Terraform/CloudFormation 예비)\n└── .github/\n    └── workflows/     # CI/CD\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server 통신**: HTTPS 기반 REST API, JWT/OAuth2 인증  \n- **Database 상호작용**: SQLAlchemy ORM + pgvector 벡터 쿼리  \n- **외부 연동**: arXiv/CrossRef/Semantic Scholar API  \n- **데이터 동기화**: 배치 크롤러 → DB 업데이트 → 캐시 무효화\n\n## 4. Performance & Optimization Strategy\n- Redis 캐싱으로 반복 쿼리·요약 결과 재사용  \n- pgvector 인덱스 튜닝 및 벡터 차원 최적화  \n- LangChain 파이프라인 병렬 처리 및 비동기 호출  \n- CDN 활용으로 이미지 전송 지연 최소화\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js, FastAPI, Supabase, Redis 설정  \n- **Essential Features**: 분야 입력 → 벡터 검색 → RAG 요약 → figure 썸네일  \n- **Basic Security**: OAuth2 로그인, HTTPS 설정  \n- **Development Setup**: Docker, GitHub Actions CI  \n- **Timeline**: 0~3개월\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 필터, 모바일 UI 개선  \n- **Performance Optimization**: 쿼리/파싱 병렬화, 캐시 정책 조정  \n- **Enhanced Security**: GDPR 데이터 처리, 보안 스캔  \n- **Monitoring Implementation**: Prometheus, Grafana, Sentry  \n- **Timeline**: 3~6개월\n\n### Phase 3: Scaling & Optimization\n- **Scalability Implementation**: Kubernetes 오토스케일, GKE/EKS 확장  \n- **Advanced Integrations**: 협업 메모, 다국어 번역, API 공개  \n- **Enterprise Features**: 관리자 대시보드, 권한 관리  \n- **Compliance & Auditing**: SOC2, ISO27001 준비  \n- **Timeline**: 6~12개월\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: LLM 환각 → RAG·출처 링크 강화  \n- **Performance Risks**: 대량 벡터 검색 지연 → 인덱스 튜닝·샤딩  \n- **Security Risks**: OAuth2 취약점 → 주기적 보안 점검  \n- **Integration Risks**: 외부 API 변경 → 버전 관리·리트라이 로직  \n- **Mitigation**: 모니터링, 캐싱, 백오프·재시도 정책\n\n### Project Delivery Risks\n- **Timeline Risks**: 의존성 지연 → 마일스톤 기반 스코프 관리  \n- **Resource Risks**: 전문 인력 부족 → 외부 컨설팅·교육  \n- **Quality Risks**: 테스트 커버리지 부족 → TDD, 코드 리뷰 강화  \n- **Deployment Risks**: 환경 차이 문제 → IaC·컨테이너 표준화  \n- **Contingency Plans**: 기능 축소 버전, 대체 서비스 활용\n\n",
      "writedAt": "2025-07-15T04:56:12.215Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guidelines for Research Paper RAG Summarization Project\n\n## 1. Project Overview\nThis project delivers an end-to-end RAG (Retrieval-Augmented Generation) pipeline for structured paper summaries.  \nBackend: FastAPI (Python), LangChain orchestration, Supabase PostgreSQL + pgvector, Redis caching, S3/CloudFront for images.  \nFrontend: Next.js (React), TypeScript, responsive dashboard with search, filters, summary cards.  \nArchitecture:  \n- Offline batch pipeline (Airflow/Cron → crawler → parser → embeddings → pre-summaries)  \n- Online serving pipeline (Next.js → FastAPI → pgvector search → LLM → cache → UI)\n\n## 2. Core Principles\n1. **Consistency**: Enforce naming, imports, formatting across all modules (measurable via lint).  \n2. **Modularity**: Single Responsibility per file/class (max 200 LOC).  \n3. **Type Safety**: Use type hints (Python) and TypeScript interfaces everywhere (100% coverage).  \n4. **Clarity**: Favor explicit code (no magic) and self-documenting names.  \n5. **Testability**: All new logic must include unit tests (≥80% coverage per module).\n\n## 3. Language-Specific Guidelines\n\n### Python (FastAPI + LangChain)\n- **File Organization**:  \n  ─ backend/app/  \n    ├── api/           # FastAPI routers  \n    ├── domains/       # user, paper, summarize  \n    ├── services/      # business logic  \n    ├── repositories/  # DB operations  \n    ├── infrastructure/# external integrations  \n    ├── core/          # config, exceptions, logger  \n    └── main.py  \n\n- **Imports**:  \n  1. Standard library  \n  2. Third-party  \n  3. Local (`from app.domains.paper import models`)  \n- **Dependency Management**:  \n  - Use `poetry` or `pip-tools`.  \n  - Pin exact versions in `pyproject.toml` or `requirements.txt`.  \n- **Error Handling**:  \n  - Raise `HTTPException` in routers.  \n  - Define custom exceptions under `core/exceptions.py`.  \n  - Centralize handlers in `api/router_exceptions.py`.  \n\n### TypeScript & React (Next.js)\n- **Directory Structure**:  \n  ─ frontend/  \n    ├── components/    # reusable UI  \n    ├── pages/         # Next.js routes  \n    ├── hooks/         # custom hooks (e.g. useSummary)  \n    ├── services/      # API clients  \n    ├── context/       # React Context providers  \n    └── styles/        # CSS/SCSS modules  \n\n- **Imports**:  \n  - Group: React/core → third-party → absolute aliases (`@/components`) → relative.  \n  - Use `tsconfig.json` `baseUrl` and `paths`.  \n\n- **Error Handling**:  \n  - Wrap async functions in `try/catch`.  \n  - Use Error Boundaries for UI.  \n  - Standardize API errors shape: `{ statusCode: number; message: string }`.\n\n### Docker & Infrastructure as Code\n- **Dockerfiles**:  \n  - Small multi-stage builds.  \n  - `COPY requirements.txt .` before `pip install`.  \n- **CI/CD (GitHub Actions)**:  \n  - Separate jobs: lint, test, build, deploy.  \n  - Use pinned action versions.\n\n## 4. Code Style Rules\n\n### MUST Follow\n1. **Use Type Hints / TypeScript Types**  \n   - Python functions require full annotations.  \n   - TSX components declare `Props` interface.  \n   Rationale: Improves readability and tooling support.  \n\n2. **Async/Await for I/O**  \n   - All DB and network calls must be `async`.  \n   Rationale: Non-blocking performance.  \n\n3. **Pydantic for Validation**  \n   - Use `BaseModel` for request/response schemas.  \n   Rationale: Ensures input correctness and auto-docs.  \n\n4. **React Function Components + Hooks**  \n   ```tsx\n   // MUST: Stateless functional component with props typing\n   import React from 'react';\n\n   interface SummaryCardProps {\n     title: string;\n     snippet: string;\n   }\n\n   const SummaryCard: React.FC<SummaryCardProps> = ({ title, snippet }) => (\n     <div className=\"card\">\n       <h3>{title}</h3>\n       <p>{snippet}</p>\n     </div>\n   );\n   ```\n   Rationale: Simplifies lifecycle and state management.\n\n5. **HTTP Status Codes & OpenAPI Tags**  \n   ```python\n   @router.get(\"/papers/{paper_id}\", response_model=PaperDto, status_code=200, tags=[\"paper\"])\n   async def get_paper(paper_id: UUID):\n       ...\n   ```\n   Rationale: Clear API semantics and auto-generated docs.\n\n### MUST NOT Do\n1. **No Monolithic Files**  \n   - Don’t put multiple domains/services in one file.  \n   - Each file ≤200 LOC.  \n2. **No Mutable Default Arguments in Python**  \n   ```python\n   # MUST NOT:\n   def fetch_chunks(model: str, cache: dict = {}):\n       ...\n   ```\n   Rationale: Leads to shared state bugs.  \n3. **No Direct SQL in Controllers**  \n   - Use repository layer.  \n4. **No Inline Styles / Magic Strings**  \n   - CSS modules or styled-components only.  \n\n## 5. Architecture Patterns\n\n### Component & Module Structure\n- **Backend Layers**  \n  1. **Presentation** (`api/routers`)  \n  2. **Service** (`services/`)  \n  3. **Repository** (`repositories/`)  \n  4. **Infrastructure** (`infrastructure/clients.py`)  \n\n- **Frontend State**  \n  - Local component state via `useState` or `useReducer`.  \n  - Global state via React Context or Zustand for auth and user preferences.  \n\n### Data Flow\n1. Frontend dispatches query →  \n2. FastAPI endpoint receives request →  \n3. Service orchestrates: repository.search_embeddings → LangChain prompt → LLM call → repository.fetch_figures → cache → response →  \n4. Frontend updates UI via SWR or React Query.  \n\n### API Design Standards\n- **RESTful Endpoints**  \n  - `/api/papers?query=...&year=2023`  \n  - `/api/users/{id}/recommendations`  \n- **Consistent Response Wrapper**  \n  ```json\n  { \"data\": {...}, \"error\": null }\n  ```\n- **Versioning**: Prefix `/v1/` in URLs.  \n\n## Example Code Snippets\n\n#### Python Service Layer\n```python\n# MUST: Business logic separated from API\nfrom app.repositories.paper import PaperRepository\nfrom app.infrastructure.llm import LLMClient\n\nclass SummaryService:\n    def __init__(self, repo: PaperRepository, llm: LLMClient):\n        self.repo = repo\n        self.llm = llm\n\n    async def generate_summary(self, query: str) -> dict:\n        chunks = await self.repo.search_embeddings(query)\n        prompt = self._build_prompt(chunks)\n        summary = await self.llm.call(prompt)\n        return summary\n\n    def _build_prompt(self, chunks: list[str]) -> str:\n        return f\"Summarize: {chunks[:3]}\"\n```\n\n#### TypeScript API Client\n```ts\n// MUST: Centralized API calls with typed responses\nimport axios from 'axios';\n\nexport interface SummaryDto {\n  title: string;\n  snippet: string;\n  figures: { url: string; caption: string }[];\n}\n\nexport async function fetchSummary(query: string): Promise<SummaryDto> {\n  const resp = await axios.get<{ data: SummaryDto }>('/api/v1/summary', {\n    params: { query },\n  });\n  return resp.data.data;\n}\n```\n\n#### Anti-Pattern Example\n```python\n# MUST NOT: Direct DB calls in router and missing types\n@router.get(\"/papers/raw\")\nasync def raw():\n    rows = db.execute(\"SELECT * FROM papers\")  # bad: raw SQL here\n    return rows\n```\nFix: Move SQL to `repositories/paper.py` and use typed models.\n\n---\n\nAdhere strictly to these guidelines. Use automated linting (flake8, black, eslint, Prettier) and enforce via CI. Continuous review ensures alignment with architecture and code quality goals.",
      "writedAt": "2025-07-15T04:56:12.215Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-15T04:56:12.215Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-15T04:56:12.215Z"
    }
  ]
}